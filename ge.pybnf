# parcing syntax: "<__>" - non-terminals, "{::}" - new line, "{:_____:}" - indentation

# Initialization, no branching
<S> ::= <init>{::}<call>
<init> ::= import numpy as np{::}import __src as src{::}<params>{::}def ge():{:X = np.array([src.solution(my_func, dimension, bounds) for i in range(n)]){::}[Xi.initRandom() for Xi in X]{::}for it in range(iterations):{:<main>:}{::}return X

# parameters
<params> ::= n = 30{::}iteration = 30{::}my_func = src.tf.ackley_function{::}dimension = 5{::}bounds = -10, 10{::}params = {'beta': .5, 'pr':.7, 'tournament':5, 'w':.5, 'c1:.5', 'c2':1, 'pa':.25, 'dp':.1}
w=0.5, c1=0.5, c2=1
# branching starts here
<main> ::= <ModificationRound> # |<ModificationRound>{::}<DropRound>

<ModificaitionRound> ::= <step> | <step><step> 
<step> ::= <X1 = src.op.<operator>(X, <sel>, <mut>, <cross>, **params}{::}X = <output>

# producing different versions of X1
<operator> ::= src.op.op_de | src.op.op_pso

<sel> ::= select_random | select_tournament

<cross> ::= crx_exponential # | crx_npoint

<mut> ::= mut_de | mut_pso | mut_cs

# ways to chose between X and X1
<output> ::= X1 | src.op.replace_if_best(X, X1) | src.op.replace_if_random(X1, X2)


<DropRound> ::= X = src.op.drop_probability(X, **params) | X = src.op.drop_worst(X, **params) # |<drop_old>



<call> ::= ge(){::}XXX_output_XXX = src.solution.best.getFitness()