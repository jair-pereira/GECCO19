# parcing syntax: "<__>" - non-terminals, "{::}" - new line, "{:_____:}" - indentation

# Initialization, no branching
<S> ::= <init>{::}<call>
<init> ::= import numpy as np{::}from src import *{::}import testFunctions as tf{::}from animation import animation{::}<params>{::}def ge(n, my_func, bounds, dimension, max_nfe):{:Solution.setProblem(my_func, bounds, dimension, maximize=False){::}X = Solution.initialize(n){::}for Xi in X:    Xi.setX(op.init_random(*Solution.bounds, Solution.dimension)){::}Solution.updateHistory(X){::}while Solution.nfe < max_nfe:{:<main>:}{::}return X:}

# parameters
<params> ::= n=<n>{::}max_nfe = 100{::}my_func = tf.ackley_function{::}dimension = 40{::}bounds = -5, 5{::}
<n> ::= 50 | 100 | 200 | 400 | 800 |1600

# branching starts here
<main> ::= <ModificationRound> |<ModificationRound>{::}<DropRound>

<ModificationRound> ::= <step> | <step>{::}<step> 
<step> ::= <param>{::}X1 = <operator>(X, <sel>, <mut>, <cross>){::}X = <output>

<operator> ::= <op1> | <op2>	
<sel> ::= <random> # | <tournament>
<cross> ::= <cross_exp> | <cross_blend>
<mut> ::= <de> | <pso>

<param> ::= w=<w>{::}c1=<c1>{::}c2=<c2>{::}beta=<beta>{::}pr=<pr>

<op1> ::= op.op_de 
<op2> ::= op.op_pso

<random> ::= op.select_random 

<cross_exp> ::= op.crx_exponential
<pr> ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

<cross_blend> ::= op.crx_exponential
<alpha> ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

<de>   ::= op.mut_de
<beta> ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

<pso> ::= op.mut_pso
<w>   ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c1>  ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c2>  ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

# ways to choose between X and X1
<output> ::= <choose_all> | <replace_if_better> | <replace_if_random>
<choose_all> ::= X1 
<replace_if_better> ::= op.replace_if_best(X, X1) 
<replace_if_random> ::= op.replace_if_random(X, X1)

<DropRound> ::= <DropRandom>|<DropWorst>|<DropOld>
<DropRandom> ::= X = op.drop_probability(X){::} 
<DropWorst> ::= X = op.drop_worst(X) {::}
<DropOld> ::= pass 

<call> ::= ge(n, my_func, bounds, dimension, max_nfe){::}XXX_output_XXX = Solution.best.getFitness()