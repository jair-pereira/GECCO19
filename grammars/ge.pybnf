# parcing syntax: "<__>" - non-terminals, "{::}" - new line, "{:_____:}" - indentation

# Initialization, no branching
<S> ::= <init>{::}<call>

<init> ::= import numpy as np{::}from src import *{::}import testFunctions as tf{::}from animation import animation{::}def ge(n, my_func, bounds, dimension, max_nfe):{:Solution.setProblem(my_func, bounds, dimension, maximize=False){::}X = Solution.initialize(n){::}for Xi in X:    Xi.setX(op.init_random(*Solution.bounds, Solution.dimension)){::}[Xi.getFitness() for Xi in X]{::}Solution.updateHistory(X){::}while Solution.nfe < max_nfe:{:{::}[Xi.getFitness() for Xi in X]{::}<main>:}{::}return X:}{::}

# BRANCHING STARTS HERE
# main
<main> ::= <ModificationRound> |<ModificationRound>{::}<param><DropRound>
<ModificationRound> ::= <step> | <step>{::}<step> | <step>{::}<step>{::}<step> 
<step> ::= <param>{::}X1 = <operator>(X, <sel>, <mut>, <cross>){::}X = <output>
<operator> ::= <op1> | <op2>	
<sel> ::= <random> # | <tournament>
<cross> ::= <cross_exp> | <cross_blend>
<mut> ::= <de> | <pso>
<output> ::= <choose_all> | <replace_if_better> | <replace_if_random>
<DropRound> ::= <DropRandom>|<DropWorst>|<DropOld>


#wrappers
<op1> ::= op.op_de 
<op2> ::= op.op_pso

#selection
<random> ::= op.select_random 

#crossover
<cross_exp> ::= op.crx_exponential
<cross_blend> ::= op.crx_blend

#mutation
<de>  ::= op.mut_de
<pso> ::= op.mut_pso

#update-rule / keep-rule
<choose_all> ::= X1 
<replace_if_better> ::= op.replace_if_best(X, X1) 
<replace_if_random> ::= op.replace_if_random(X, X1)

#drop
<DropRandom> ::= X = op.drop_probability(X){::} 
<DropWorst>  ::= X = op.drop_worst(X) {::}
<DropOld>    ::= pass 

#parameters
<param> ::= op.param = {"'w'":<w>,"'c1'":<c1>,"'c2'":<c2>,"'alpha'":<alpha>,"'beta'":<beta>,"'pr'":<pr>}{::}
<n>     ::=   50 | 100  | 200  | 400  | 800  | 1600
<pr>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<alpha> ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<beta>  ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<w>     ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c1>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c2>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

#exec
<call> ::= ge(n=<n>, my_func=tf.ackley_function, bounds=(-15,15), dimension=40, max_nfe=1000){::}XXX_output_XXX = Solution.best.getFitness()