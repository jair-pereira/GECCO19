# parcing syntax: "<__>" - non-terminals, "{::}" - new line, "{:_____:}" - indentation

# Initialization, no branching
<S> ::= <init>{::}<call>

<init> ::= import numpy as np{::}from src import *{::}import testFunctions as tf{::}from animation import animation{::}def ge(n, my_func, bounds, dimension, max_nfe):{:Solution.setProblem(my_func, bounds, dimension, maximize=False){::}X = Solution.initialize(n){::}for Xi in X:    Xi.setX(op.init_random(*Solution.bounds, Solution.dimension)){::}[Xi.getFitness() for Xi in X]{::}Solution.updateHistory(X){::}while Solution.nfe < max_nfe:{:{::}[Xi.getFitness() for Xi in X]{::}<main>:}{::}return X:}{::}

# BRANCHING STARTS HERE
# main
<main> ::= <ModificationRound> |<ModificationRound>{::}<param><DropRound>
<ModificationRound> ::= <step> | <step>{::}<step> | <step>{::}<step>{::}<step> 
<step>      ::= <select><operator1><output> | <select><select><operator2><output> | <select><select><select><operator3><output>
<select>    ::= <select_random> | <select_tournament> | <select_current> #| <select_roullete>
<operator1> ::= <op_pso> | <op_cs> | <op_mut_uni>
<operator2> ::= <op_crx_blend> | <op_crx_exp> # | <op_crx_bin> 
<operator3> ::= <op_mut_de>
<output>    ::= <choose_all> | <replace_if_better> | <replace_if_random>
<DropRound> ::= <DropRandom>|<DropWorst> |<DropOld>

#selection
<select_random> ::= op.select_random
<select_tournament> ::= op.select_tournament
<select_current> ::= op.select_current
# <select_roullete> ::= op.select_roullete

#operators 1-1
<op_pso>     ::= op.w_pso(S)
<op_cs>      ::= op.w_levy_flight(S)
<op_mut_uni> ::= op.w_mut_uni(S)

#operators 2-2
<op_crx_blend> ::= op.w_crx_blend(S)
<op_crx_exp>   ::= op.w_crx_exp(S)
# <op_crx_bin>   ::= op.w_crx_bin(S)

#operators 3-1
<op_mut_de> ::= op.w_mut_de(S)

#output (update-rule / keep-rule)
<choose_all> ::= X1 
<replace_if_better> ::= op.replace_if_best(X, X1) 
<replace_if_random> ::= op.replace_if_random(X, X1)

#drop
<DropRandom> ::= X = op.drop_probability(X){::} 
<DropWorst>  ::= X = op.drop_worst(X) {::}
<DropOld>    ::= pass 

#parameters
<param> ::= op.param = {"'w'":<w>,"'c1'":<c1>,"'c2'":<c2>,"'alpha'":<alpha>,"'beta'":<beta>,"'pr'":<pr>}{::}
<n>     ::=   50 #| 100  | 200  | 400  | 800  | 1600
<pr>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<alpha> ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<beta>  ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<w>     ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c1>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00
<c2>    ::= 0.00 | 0.25 | 0.50 | 0.75 | 1.00 | 2.00

#exec
<call> ::= ge(n=<n>, my_func=tf.ackley_function, bounds=(-15,15), dimension=40, max_nfe=1000){::}XXX_output_XXX = Solution.best.getFitness()